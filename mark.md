## 编码风格

### 使用assign代替if/else

#### if/else 和 case缺点:

1. 不能传传播不定态

    ```verilog
    if(a)
        out = in1;
    else 
        out = in2;
    
    
    // 推荐
    assign out = a ? in1 : in2;
    ```

    假设a的值为X不定态，verilog中会将其等效为a = 0，从而out = in2，没有将a的不定态转播出去。

2. 会产生优先级选择电路而不是并行选择电路，面积和时序不够均匀

    ```verilog
    	if(sel1)
        out = in1[3:0];
    else if(sel2)
        out = in2[3:0];
    else if(sel3)
        out = in3[3:0];
    else
        out = 4'b0;
    
    // 优先选择
    assign out = sel1 ? in1[3:0] : 
        		 sel2 ? in2[3:0] :
        		 sel3 ? in3[3:0] :
               	 4'b0;
    
    // 并行选择
    assign out = ({4{sel1}} & in1[3:0]) |
        		 ({4{sel2}} & in2[3:0]) |
        		 ({4{sel3}} & in3[3:0]);
    ```

    

## 流水线技术

### 流水线中的数据冲突

#### 数据冲突类型

1. `WAR`

​	instr1         `<- x1`

​	instr2	`-> x1`

2. `WAW`

​	instr1	`10 -> x1`

​	instr2	`20 -> x1`

3. `RAW`

​	instr1	`110 -> x1`

​	instr2	`<- x1`

#### 解决办法

(1)`WAW`和`WAR`可以通过寄存器重命名消除，无须担心执行顺序

​	寄存器重命名技术在Tomasulo算法中通过`保留站`和`ROB[Re-order Buffer]`完成，或者纯物理寄存器的方式完成。

(2)`RAW`属于真数据相关

​	没有办法通过寄存器重命名解决，一旦产生RAW指令，后续的指令一定要使用和它有`RAW`前序指令产生的结果，从而造成流水线停顿。		解决方法:

**动态调度**

 1. 数据旁路传播，让前序指令的结果尽快通过旁路传播给后续指令相关操作数。

 2. 让后续指令在等待过程中不阻塞流水线，让其他无关的指令执行。

 3. 保留站无法做到很深的深度

 4. 最新的高性能处理器在每个运算单元前面配置`乱序发射队列`，发射队列仅关心`RAW`相关性，不存放操作数，可以做到较深的深度。

    发射队列中的相关性一旦解除，就可以发射出来读取寄存器，然后再发送给执行单元进行运算。

### E200中的流水线

![image-20221113175331592](E:\xproj\e200_x\mark.assets\image-20221113175331592.png)

1. 流水线第一级为`取指`
2. `译码` `执行` `写回`处于同一个时钟周期，处于流水线第二级
3. `访存`处于流水线第三级

## 取指

![image-20221113205949962](E:\xproj\e200_x\mark.assets\image-20221113205949962.png)

### IFU主要功能

- 对取回的指令进行简单的译码

- 简单的分支预测

    向后跳转预测为跳，向前跳转预测为不跳

- 生成取指的PC

- 根据PC的值访问`ITCM`或`BIU`

### 取指的快和连续不断

#### 快

取指大多发生在`ITCM`中，该处理器大多用于低功耗嵌入式处理器，代码量不大

`ITCM`采用单周期访问

#### 连续不断

采用简单的静态分支预测

为了连续不断，需要在一个周期内算出下一个PC，所以需要简单译码，判断当前指令是普通指令还是分支跳转指令。
